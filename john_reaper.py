import subprocess
import time
import re
import os
import zipfile

class JohnTheRipperProcessor:
    """This class provides the methods to interact with the John the Ripper tool."""
    def __init__(self):
        # Path to the John the Ripper executable
        self.john_path = r"C:/Users/blanc/4¬∫ UNIVERSIDAD/TFG/Crawler_Instagram/john-the-reaper/run/john.exe"
        # Path to the .pot file used by John to store cracked passwords
        self.pot_file = r"C:/Users/blanc/4¬∫ UNIVERSIDAD/TFG/Crawler_Instagram/john-the-reaper/run/john.pot"

    @staticmethod
    def compress_file(source_file, zip_destination):
        """Compresses the output of the file that contains all possible combinations that the execution of John the Ripper creates into .zip format."""
        with zipfile.ZipFile(zip_destination, 'w', zipfile.ZIP_DEFLATED) as zipf:
            zipf.write(source_file, arcname=os.path.basename(source_file))

    def run_john(self, wordlist_file, profile, mode):
        """Executes John the Ripper and saves statistics and results in an output file."""
        name_profile, _ = os.path.splitext(profile)
        password_file = "passwords/" + profile
        results_file = "statistics/statistics_" + profile
        stdout_file = "words_generated/words_" + profile

        try:
            # Clear previous .pot file if it exists
            if os.path.exists(self.pot_file):
                os.remove(self.pot_file)

            # Prepare arguments based on mode
            if mode == "simple":
                args = ["--format=Raw-MD5", f"--wordlist={wordlist_file}"]
            elif mode == "intermediate":
                args = ["--format=Raw-MD5", f"--wordlist={wordlist_file}", "--rules=Jumbo"]
            elif mode == "advanced":
                args = ["--format=Raw-MD5", f"--wordlist={wordlist_file}", "--rules=InstagramRules"]
            else:
                return "Unrecognized mode."

            # Count total number of passwords that will be tested
            total_passwords = 0
            if mode in ["intermediate", "advanced"]:
                stdout_rules = "Jumbo" if mode == "intermediate" else "InstagramRules"
                stdout_command = [self.john_path, f"--wordlist={wordlist_file}", f"--rules={stdout_rules}", "--stdout"]

                with open(stdout_file, "w", encoding="utf-8") as f_out:
                    subprocess.run(stdout_command, stdout=f_out, stderr=subprocess.PIPE, text=True)

                with open(stdout_file, "r", encoding="latin-1") as f_count:
                    total_passwords = sum(1 for _ in f_count)

                # Compress and delete the temporary file
                self.compress_file(stdout_file, "words_generated/words_" + name_profile + ".zip")
                os.remove(stdout_file)
            else:
                with open(wordlist_file, "r", encoding="utf-8") as f_count:
                    total_passwords = sum(1 for _ in f_count)

            # Execute John the Ripper 
            start_time = time.time()
            command = [self.john_path] + args + [password_file]
            process = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            elapsed_time = time.time() - start_time

            # Save results to statistics file
            with open(results_file, "w", encoding="utf-8") as f_result:
                f_result.write("==== JOHN THE RIPPER EXECUTION ====\n")
                f_result.write(f"üïí Execution time: {elapsed_time:.2f} seconds\n")
                f_result.write(f"üõ†Ô∏è Selected mode: {mode}\n\n")

                if process.returncode != 0:
                    f_result.write("‚ö†Ô∏è Error during execution:\n")
                    f_result.write(process.stderr + "\n")
                    return f"‚ö†Ô∏è Error running John the Ripper:\n{process.stderr}"

                f_result.write("üìÑ John the Ripper Standard Output:\n")
                f_result.write(process.stdout + "\n\n")

                # Show cracked passwords
                show_command = [self.john_path, "--show", "--format=Raw-MD5", password_file]
                show_process = subprocess.run(show_command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
                show_output = show_process.stdout.strip()

                f_result.write("==== CRACKED PASSWORDS ====\n")
                matches = re.findall(r"(\S+):(.+)", show_output)
                if matches:
                    for user, password in matches:
                        f_result.write("Password found before exhausting the dictionary.\n")
                        f_result.write(f"üîê User: {user}, Password: {password}\n")
                else:
                    f_result.write("No passwords found.\n")
                    f_result.write(f"Total passwords generated by John the Ripper: {total_passwords}\n")

            # Return summary for the GUI
            if matches:
                return f"Password found in {elapsed_time:.2f} seconds! üéâ\n"
            else:
                return f"No password was cracked.\n"

        except Exception as e:
            with open("resultados_john_reaper.txt", "w", encoding="utf-8") as f_result:
                f_result.write("‚ö†Ô∏è Unexpected error:\n")
                f_result.write(str(e))
            return f"‚ö†Ô∏è An error occurred: {str(e)}"
